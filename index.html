<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Thesis Defense – Aevar Andri Amundinusarson Oefjoerd</title>

  <!-- MathJax for LaTeX rendering -->
  <script>
    window.MathJax = {
      tex: { inlineMath: [['\\(','\\)'], ['$', '$']] },
      svg: { fontCache: 'global' }
    };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" async></script>

  <style>
    :root {
      --bg: #f5f7fb;
      --fg: #111827;
      --accent: #2563eb;
      --muted: #6b7280;
      --tag-bg: #e5edff;
      --tag-fg: #1d4ed8;
      --code-bg: #e5e7eb;
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      background: var(--bg);
      color: var(--fg);
      overflow: hidden;
    }

    .slide {
      display: none;
      width: 100vw;
      height: 100vh;
      padding: 56px 80px 48px 80px;
      box-sizing: border-box;
    }

    .slide.active {
      display: block;
    }

    h1 {
      margin: 0;
      font-size: 3.5rem;
      font-weight: 650;
    }

    .slide-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.2em;
    }

    h2 {
      margin: 1.2em 0 0.4em 0;
      font-size: 2.2rem;
    }

    /* Remove top margin from first element after slide-header */
    .slide-header + h2,
    .slide-header + p,
    .slide-header + ul,
    .slide-header + ol,
    .slide-header + div {
      margin-top: 0;
    }

    /* Remove top margin from first h2 inside two-column/three-column that follows slide-header */
    .slide-header + .two-column h2:first-child,
    .slide-header + .three-column h2:first-child,
    .slide-header + .two-column > div:first-child > h2:first-child,
    .slide-header + .three-column > div:first-child > h2:first-child,
    .slide-header + .two-column > div > h2:first-child,
    .slide-header + .three-column > div > h2:first-child {
      margin-top: 0;
    }

    p {
      margin: 0.25em 0 0.25em 0;
      font-size: 1.7rem;
      line-height: 1.4;
    }

    ul, ol {
      margin: 0.2em 0 0.2em 1.1em;
      padding-left: 0.8em;
      font-size: 1.7rem;
      line-height: 1.4;
    }

    li {
      margin: 0.1em 0;
    }

    .tag {
      display: inline-block;
      padding: 0.14em 0.6em;
      border-radius: 999px;
      font-size: 1.3rem;
      font-weight: 500;
      background: var(--tag-bg);
      color: var(--tag-fg);
      margin: 0;
      flex-shrink: 0;
    }

    .muted {
      color: var(--muted);
      font-size: 1.4rem;
    }

    .two-column {
      display: grid;
      grid-template-columns: 1.1fr 1fr;
      gap: 40px;
    }

    .two-column > div {
      min-width: 0;
    }

    .three-column {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 30px;
    }

    .three-column > div {
      min-width: 0;
    }

    .center {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      text-align: center;
      flex-direction: column;
    }

    .title-main {
      font-size: 4.9rem;
      margin-bottom: 0.3em;
    }

    .subtitle {
      font-size: 2.1rem;
      margin-bottom: 0.5em;
    }

    .small-text {
      font-size: 1.5rem;
    }

    .equation {
      margin: 0.4em 0;
      font-size: 1.7rem;
    }

    mjx-container {
      font-size: 100% !important;
    }

    mjx-container[display="true"] {
      font-size: 100% !important;
    }

    .footer {
      position: absolute;
      bottom: 16px;
      left: 80px;
      right: 80px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 1.3rem;
      color: var(--muted);
    }

    .progress {
      height: 4px;
      background: #e5e7eb;
      border-radius: 999px;
      overflow: hidden;
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
    }

    .progress-bar {
      height: 100%;
      width: 0%;
      background: var(--accent);
      transition: width 0.25s ease-out;
    }

    .slide-number {
      position: absolute;
      bottom: 16px;
      right: 80px;
      font-size: 1.5rem;
      color: var(--muted);
    }

    code {
      background: var(--code-bg);
      padding: 0 0.2em;
      border-radius: 3px;
      font-size: 0.82em;
    }

    /* Make things a bit tighter on small screens */
    @media (max-width: 900px) {
      .slide {
        padding: 40px 24px 40px 24px;
      }
      .two-column {
        grid-template-columns: 1fr;
      }
      h1 {
        font-size: 1.7rem;
      }
    }
  </style>
</head>

<body>

  <!-- Slide 1 – Title -->
  <section class="slide active">
    <div class="center">
      <h1 class="title-main">Simulation-to-Hardware Validation of MPC<br/>for Binary Thruster 2D CubeSat Control</h1>
      <div class="subtitle">Aevar Andri Amundinusarson Oefjoerd</div>
      <p>M.Sc. Mechanical Engineering, University of Kentucky</p>
      <p class="small-text" style="margin-top: 1.5em;">
        Committee: Dr. Hasan Poonawala · Dr. Michael Seigler · Dr. Jesse Hoagg<br/>
        December 2025
      </p>
    </div>
    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Slide 2 – Hardware Demo Video -->
  <section class="slide">
    <div class="slide-header">
      <h1>Hardware Demonstration</h1>
      <span class="tag">The Result</span>
    </div>
    <div style="display: flex; justify-content: center; align-items: center; height: 70vh;">
      <video controls style="max-height: 100%; max-width: 100%; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.15);">
        <source src="Data/Comparison/Test/Video_sped_up.mp4" type="video/mp4">
        Your browser does not support the video tag.
      </video>
    </div>
    <p class="muted" style="text-align: center; margin-top: 0.5em;">Video is sped up 2.5× — actual mission duration: ~3 minutes</p>
    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Slide 3 – Outline -->
  <section class="slide">
    <h1>Outline</h1>
    <ul>
      <li><strong>Part 1:</strong> Problem, motivation, research questions, approach</li>
      <li><strong>Part 2:</strong> System – physical platform and simulation setup</li>
      <li><strong>Part 3:</strong> Math and MPC – what is solved every control step</li>
      <li><strong>Part 4:</strong> Results – simulation vs hardware and answers to the questions</li>
      <li><strong>Backup slides:</strong></li>
    </ul>
    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Slide 3 – Motivation: Inspection Satellites -->
  <section class="slide">
    <div class="slide-header">
      <h1>Motivation: Inspection Satellites</h1>
      <span class="tag">Part 1 – Motivation</span>
    </div>
    <p>
      The number of satellites in orbit is increasing rapidly, and the need for
      inspection and proximity-operations satellites is growing with it.
    </p>
    <p>
      This thesis demonstrates how a small planar “inspection satellite”
      can be controlled in 2D using:
    </p>
    <ul>
      <li>A Model Predictive Control (MPC) algorithm</li>
      <li>Binary (on/off) thrusters</li>
    </ul>
    <p>
      The focus is on contributing to inspection-satellite technology by
      demonstrating controlled inspection-type maneuvers with a realistic actuator setup.
    </p>
    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Slide 4 – Control requirements and binary thrusters -->
  <section class="slide">
    <div class="slide-header">
      <h1>Control Requirements and Binary Thrusters</h1>
      <span class="tag">Part 1 – Motivation</span>
    </div>

    <h2>Inspection satellites must:</h2>
    <ul>
      <li>Perform precise maneuvers for inspection and proximity operations.</li>
      <li>Respect strict path and pointing constraints around other spacecraft.</li>
      <li>Operate with limited propellant and tight fuel budgets.</li>
    </ul>

    <h2>Binary thrusters:</h2>
    <ul>
      <li>Actuators are either fully <strong>ON</strong> or fully <strong>OFF</strong>.</li>
      <li>Thrust level is not continuously adjustable during operation.</li>
      <li>Individual thrusters are not identical due to plumbing and hardware differences.</li>
      <li>Control problem involves discrete inputs, asymmetric actuators, and strict constraints.</li>
    </ul>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Slide 5 – Controller choice: Why MPC? -->
  <section class="slide">
    <div class="slide-header">
      <h1>Controller Choice: Why MPC?</h1>
      <span class="tag">Part 1 – Controller</span>
    </div>

    <div class="two-column">
      <div>
        <h2>Control objective</h2>
        <ul>
          <li>Follow a planned trajectory in 2D (position + heading).</li>
          <li>Respect velocity and rotation limits.</li>
          <li>Use binary, asymmetric thrusters efficiently.</li>
        </ul>

        <h2>Why Model Predictive Control?</h2>
        <ul>
          <li>Predicts future motion over a finite horizon.</li>
          <li>Explicitly enforces state and input constraints.</li>
          <li>Handles binary thrusters directly via mixed-integer optimization.</li>
          <li>Quadratic cost + binary variables → MIQP → predictable solve times.</li>
        </ul>
      </div>

      <div>
        <h2>Alternatives considered</h2>
        <ul>
          <li><strong>PID / LQR:</strong> No explicit binary or fuel modeling, constraints handled indirectly.</li>
          <li><strong>Bang–bang:</strong> Hard to tune, no formal constraint guarantees.</li>
          <li><strong>Nonlinear MPC (MINLP):</strong> More accurate but computationally expensive with unpredictable solve times.</li>
        </ul>
      </div>
    </div>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Slide 6 – Literature gap -->
  <section class="slide">
    <div class="slide-header">
      <h1>Literature Gap</h1>
      <span class="tag">Part 1 – Literature</span>
    </div>

    <h2>Prior work on spacecraft MPC</h2>
    <ul>
      <li>MPC for spacecraft widely studied, but often with <strong>continuous</strong> or <strong>relaxed</strong> thruster models.</li>
      <li>Binary thruster constraints sometimes handled by rounding or pulse-width modulation after solving.</li>
      <li>Hardware validation of mixed-integer MPC with true on/off thrusters is less common.</li>
    </ul>

    <h2>Gap addressed by this thesis</h2>
    <ul>
      <li><strong>Explicit binary decisions:</strong> Thrusters modeled as \(u_i \in \{0,1\}\) inside the optimization.</li>
      <li><strong>Calibrated asymmetry:</strong> Each thruster's measured force used directly in the model.</li>
      <li><strong>Simulation-to-hardware validation:</strong> Same controller code, same model, compared on both platforms.</li>
    </ul>


    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Slide 7 – Research questions -->
  <section class="slide">
    <div class="slide-header">
      <h1>Research Questions</h1>
      <span class="tag">Part 1 – Questions</span>
    </div>
    <ol>
      <li>
        <strong>Model accuracy for tuning:</strong><br/>
        Can a linear planar model, updated with the current heading, predict tracking performance,
        fuel usage, and final settling well enough to tune MPC in simulation before hardware experiments?
      </li>
      <li>
        <strong>Compensation for asymmetric thrusters:</strong><br/>
        If each thruster is individually calibrated and those values are used in the model,
        can MPC compensate for actuator asymmetry?
      </li>
      <li>
        <strong>Real-time feasibility of mixed-integer MPC:</strong><br/>
        Can the mixed-integer optimization be solved reliably every 60ms without missing
        deadlines over a full inspection mission?
      </li>
    </ol>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Slide 8 – Approach overview -->
  <section class="slide">
    <div class="slide-header">
      <h1>Approach Overview</h1>
      <span class="tag">Part 1 – Approach</span>
    </div>

    <ul>
      <li>Build a planar “inspection satellite” testbed:
        <ul>
          <li>Air-bearing platform with eight calibrated on/off thrusters.</li>
        </ul>
      </li>
      <li>Develop an MPC controller using:
        <ul>
          <li>A linear planar model with an input matrix updated from the current heading.</li>
          <li>Explicit binary thruster decisions.</li>
          <li>Constraints on velocities and rotation.</li>
        </ul>
      </li>
      <li>Implement the same MPC and model in:
        <ul>
          <li>A simulation environment.</li>
          <li>The real hardware system.</li>
        </ul>
      </li>
      <li>Run the same inspection mission in simulation and on hardware and compare:
        <ul>
          <li>Trajectory tracking.</li>
          <li>Per-thruster and total thruster usage.</li>
          <li>Solve times and real-time performance.</li>
        </ul>
      </li>
    </ul>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Slide 9 – Mechanical platform -->
  <section class="slide">
    <div class="slide-header">
      <h1>Mechanical Platform</h1>
      <span class="tag">Part 2 – System</span>
    </div>

    <div class="two-column">
      <div>
        <h2>Main chassis</h2>
        <ul>
          <li>Cubic structure, approximately 290 × 290 × 150&nbsp;mm.</li>
          <li>Houses thrusters, manifolds, valves, tubing, and onboard electronics.</li>
        </ul>

        <h2>Air-bearing platform</h2>
        <ul>
          <li>Mounted to the bottom of the chassis.</li>
          <li>Creates a thin air film between the platform and floor.</li>
          <li>Provides nearly frictionless planar motion.</li>
        </ul>

        <h2>High-pressure air cylinder platform</h2>
        <ul>
          <li>Holds compressed-air cylinder and pressure regulators.</li>
          <li>Supplies air to thrusters and air bearings.</li>
        </ul>
      </div>

      <div style="display: flex; justify-content: center; align-items: center;">
        <img src="Presentation_images/Mechanical_Platform.png" alt="Mechanical Platform" style="max-height: 80vh; max-width: 110%; object-fit: contain;">
      </div>
    </div>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Slide 10 – Environment, sensing, computing -->
  <section class="slide">
    <div class="slide-header">
      <h1>Experimental Environment, Sensing, and Computing</h1>
      <span class="tag">Part 2 – System</span>
    </div>

    <div class="two-column">
      <div>
        <h2>Testing area</h2>
        <ul>
          <li>6&nbsp;m × 6&nbsp;m epoxy-coated floor.</li>
          <li>Flat, smooth surface designed for air-bearing operation.</li>
          <li>Large enough for inspection-style trajectories.</li>
        </ul>

        <h2>Sensing</h2>
        <ul>
          <li>Optical motion-capture system measures pose \((x, y, \theta)\) in the world frame.</li>
          <li>Reflective markers on the chassis define the body frame.</li>
          <li>Pose streamed in real time to the ground-station computer.</li>
        </ul>

        <h2>Computing and communication</h2>
        <ul>
          <li>Ground-station computer:
            <ul>
              <li>Receives motion-capture data and builds state \(\mathbf{x}_k\).</li>
              <li>Solves the MPC MIQP every 60&nbsp;ms.</li>
              <li>Sends thruster on/off commands via wireless link.</li>
            </ul>
          </li>
          <li>Onboard electronics:
            <ul>
              <li>Decode commands from the ground station.</li>
              <li>Activate the eight solenoid valves according to MPC output.</li>
            </ul>
          </li>
        </ul>
      </div>

      <div style="display: flex; justify-content: center; align-items: center;">
        <img src="Presentation_images/Experimental_Environment_Sensing_and_Computing.png" alt="Experimental Environment, Sensing, and Computing" style="max-height: 70vh; max-width: 100%; object-fit: contain;">
      </div>
    </div>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Slide 11 – Thruster layout and calibration -->
  <section class="slide">
    <div class="slide-header">
      <h1>Thruster Layout and Calibration</h1>
      <span class="tag">Part 2 – System</span>
    </div>

    <div class="two-column">
      <div>
        <h2>Layout</h2>
        <ul>
          <li>Eight thrusters located at known positions around the chassis.</li>
          <li>Directions chosen to provide both translation and rotation authority.</li>
        </ul>

        <h2>Calibration</h2>
        <ul>
          <li>Effective thrust of each thruster measured at operating pressure.</li>
          <li>Asymmetries (≈10% or more) are preserved in the model.</li>
        </ul>

        <h2>Role in control</h2>
        <ul>
          <li>Calibrated forces and lever arms are used to construct the input matrix \(B(\theta_k)\).</li>
          <li>MPC uses this information to optimally select thruster firings.</li>
        </ul>
      </div>

      <div style="display: flex; justify-content: center; align-items: center;">
        <img src="Presentation_images/Thruster_Layout_and_Calibration.png" alt="Thruster Layout and Calibration" style="max-height: 100vh; max-width: 110%; object-fit: contain;">
      </div>
    </div>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Slide 12 – Hardware and simulation loops -->
  <section class="slide">
    <div class="slide-header">
      <h1>Hardware and Simulation Control Loops</h1>
      <span class="tag">Part 2 – System</span>
    </div>

    <div class="two-column">
      <div>
        <h2>Hardware loop (every 60&nbsp;ms)</h2>
        <ol>
          <li>Motion capture measures pose \((x, y, \theta)\).</li>
          <li>Ground station constructs state vector
            \[
              \mathbf{x}_k =
              \begin{bmatrix}
              x & y & \theta & v_x & v_y & \omega
              \end{bmatrix}^\top.
            \]
          </li>
          <li>MPC solves a MIQP to compute binary thruster commands \(\mathbf{u}_k\).</li>
          <li>Commands are sent to the hardware satellite and applied for the next 60&nbsp;ms.</li>
        </ol>
      </div>

      <div>
        <h2>Simulation loop (every 60&nbsp;ms)</h2>
        <ol>
          <li>Linear dynamics model updates the simulated state \((x, y, \theta)\) using \(\mathbf{u}_k\).</li>
          <li>Ground station constructs state vector
            \[
              \mathbf{x}_k =
              \begin{bmatrix}
              x & y & \theta & v_x & v_y & \omega
              \end{bmatrix}^\top.
            \]
          </li>
          <li>MPC solves a MIQP to compute binary thruster commands \(\mathbf{u}_k\).</li>
          <li>Commands are sent to the simulated satellite and applied for the next 60&nbsp;ms.</li>
        </ol>
      </div>
    </div>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- ============== PART 3: BUILDING THE CONTROLLER ============== -->

  <!-- Slide 13 – The Control Problem -->
  <section class="slide">
    <div class="slide-header">
      <h1>The Control Problem</h1>
      <span class="tag">Part 3 – The Goal</span>
    </div>

    <div class="two-column">
      <div>
        <h2>What information the controller has</h2>
        <ul>
          <li>Current state \((x, y, \theta)\) of the satellite in world frame</li>
          <li>Position and force vectors of the thrusters in body frame</li>
          <li>A target state</li>
        </ul>

        <h2>What the controller decides</h2>
        <ul>
          <li>Which thrusters to fire at each time step</li>
        </ul>

        <h2>Objectives (minimize)</h2>
        <ul>
          <li>Tracking error — get close to target</li>
          <li>Fuel usage — don't waste propellant</li>
          <li>Thruster switching — reduce wear</li>
        </ul>
      </div>

      <div>
        <h2>The approach: Model Predictive Control</h2>
        <p style="margin-top: 0.5em;">Every 60&nbsp;ms:</p>
        <ol>
          <li>Measure/Estimate the current state</li>
          <li>Predict the state over the next N steps</li>
          <li>Find the best thruster commands to reach the target state</li>
          <li>Apply the first command, then repeat the loop</li>
        </ol>

        <p style="margin-top: 1em;"><strong>Key requirement:</strong></p>
        <p>We need a mathematical model that predicts how thruster firings affect the satellite's motion to estimate the effects of control inputs.</p>

        <p class="muted" style="margin-top: 1em;">
          The next slides build this model step by step.
        </p>
      </div>
    </div>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Slide 14 – Body to World Frame -->
  <section class="slide">
    <div class="slide-header">
      <h1>Body Frame vs World Frame</h1>
      <span class="tag">Part 3 – Coordinate Frames</span>
    </div>

    <div class="two-column">
      <div>
        <h2>The problem</h2>
        <ul>
          <li>Thrusters are <strong>fixed to the satellite body</strong></li>
          <li>Each thruster produces force \(\mathbf{f}_i^{\text{body}}\) in a known direction</li>
          <li>But we predict motion in the <strong>world frame</strong> (lab coordinates)</li>
        </ul>

        <h2>The solution: rotation matrix</h2>
        <p class="equation">
          \[
            \mathbf{f}_i^{\text{world}} = R(\theta) \, \mathbf{f}_i^{\text{body}}
          \]
        </p>
        <p class="equation">
          \[
            R(\theta) =
            \begin{bmatrix}
            \cos\theta & -\sin\theta \\
            \sin\theta & \cos\theta
            \end{bmatrix}
          \]
        </p>
      </div>

      <div>
        <h2>Example</h2>
        <p>A thruster pointing "forward" in body frame:</p>
        <ul>
          <li>At \(\theta = 0°\): pushes in +x world direction</li>
          <li>At \(\theta = 90°\): pushes in +y world direction</li>
          <li>At \(\theta = 180°\): pushes in −x world direction</li>
        </ul>

        <h2>Why this matters</h2>
        <ul>
          <li>The rotation depends on the current heading \(\theta_k\)</li>
          <li>This is why our input matrix \(B\) depends on \(\theta\)</li>
          <li>Same thruster command → different world-frame effect depending on orientation</li>
        </ul>
      </div>
    </div>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Slide 15 – State Vector -->
  <section class="slide">
    <div class="slide-header">
      <h1>The State Vector: What We Track</h1>
      <span class="tag">Part 3 – State</span>
    </div>

    <div class="two-column">
      <div>
        <h2>Six quantities define the satellite's state</h2>
        <p class="equation">
          \[
            \mathbf{x}_k =
            \begin{bmatrix}
            x \\ y \\ \theta \\ v_x \\ v_y \\ \omega
            \end{bmatrix}
            =
            \begin{bmatrix}
            \text{x position} \\
            \text{y position} \\
            \text{heading angle} \\
            \text{x velocity} \\
            \text{y velocity} \\
            \text{angular velocity}
            \end{bmatrix}
          \]
        </p>

        <p class="muted" style="margin-top: 0.5em;">
          Subscript \(k\) = discrete time step (every 60&nbsp;ms).
        </p>
      </div>

      <div>
        <h2>Hardware: measured by OptiTrack</h2>
        <p style="margin-bottom: 0.3em;">\(x_k, y_k, \theta_k\): directly from motion capture (every 8.33&nbsp;ms)</p>
        <p style="margin-bottom: 0.3em;">Velocities via finite differences:</p>
        <p class="equation">
          \[
            v_{x,k} = \frac{x_k - x_{k-1}}{\Delta t}, \quad
            v_{y,k} = \frac{y_k - y_{k-1}}{\Delta t}, \quad
            \omega_k = \frac{\theta_k - \theta_{k-1}}{\Delta t}
          \]
        </p>

        <h2>Simulation: computed from dynamics</h2>
        <p style="margin-bottom: 0.3em;">Integrate net forces and torques:</p>
        <p class="equation">
          \[
            v_{x,k+1} = v_{x,k} + \frac{F_x}{m} \Delta t, \quad
            v_{y,k+1} = v_{y,k} + \frac{F_y}{m} \Delta t
          \]
        </p>
        <p class="equation">
          \[
            x_{k+1} = x_k + v_{x,k} \Delta t, \quad
            y_{k+1} = y_k + v_{y,k} \Delta t
          \]
        </p>
        <p class="equation">
          \[
            \omega_{k+1} = \omega_k + \frac{\tau}{I_z} \Delta t, \quad
            \theta_{k+1} = \theta_k + \omega_k \Delta t
          \]
        </p>
        <p class="muted">
          where \(F_x = \sum_i f_{ix}^{\text{world}}\), \(F_y = \sum_i f_{iy}^{\text{world}}\), \(\tau = \sum_i \tau_i\)
        </p>

        <p class="muted" style="margin-top: 0.3em;">
          Same MPC code receives \(\mathbf{x}_k\) from either source.
        </p>
      </div>
    </div>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Slide 16 – Input Vector -->
  <section class="slide">
    <div class="slide-header">
      <h1>The Input Vector: What We Control</h1>
      <span class="tag">Part 3 – Input</span>
    </div>

    <div class="two-column">
      <div>
        <h2>Eight binary thruster commands</h2>
        <p class="equation">
          \[
            \mathbf{u}_k =
            \begin{bmatrix}
            u_1 \\ u_2 \\ u_3 \\ u_4 \\ u_5 \\ u_6 \\ u_7 \\ u_8
            \end{bmatrix}
            \quad \text{where } u_i \in \{0, 1\}
          \]
        </p>

        <ul style="margin-top: 1em;">
          <li>\(u_i = 0\): thruster \(i\) is OFF</li>
          <li>\(u_i = 1\): thruster \(i\) is ON</li>
        </ul>

        <p class="muted" style="margin-top: 1em;">
          No partial thrust — this is what makes the problem "mixed-integer."
        </p>
      </div>

      <div>
        <h2>Thruster layout</h2>
        <ul>
          <li>8 thrusters at known positions around chassis</li>
          <li>Each has a calibrated force magnitude</li>
          <li>Each has a fixed direction (in body frame)</li>
          <li>Some pairs produce pure translation, some pairs produce rotation</li>
        </ul>

        <h2>What MPC decides</h2>
        <p>For each of the next N=12 time steps, which of the 8 thrusters should be ON?</p>
        <p class="muted" style="margin-top: 0.5em;">
          That's 8 × 12 = 96 binary decisions every 60&nbsp;ms.
        </p>
      </div>
    </div>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Slide 17 – The Dynamics Equation -->
  <section class="slide">
    <div class="slide-header">
      <h1>The Discrete-Time State-Space Equation</h1>
      <span class="tag">Part 3 – Dynamics</span>
    </div>

    <h2>How does the state change when we fire thrusters?</h2>
    <p class="equation" style="margin: 0.5em 0;">
      \[
        \mathbf{x}_{k+1} = A \, \mathbf{x}_k + B(\theta_k) \, \mathbf{u}_k
      \]
    </p>
    <p class="muted" style="text-align: center; margin-top: -0.3em;">
      Linear time-varying (LTV) state-space model — B depends on current heading θₖ
    </p>

    <div class="two-column">
      <div>
        <h2>\(A\) — State transition matrix</h2>
        <p><em>"How the state evolves on its own"</em></p>
        <p class="equation">
          \[
            A =
            \begin{bmatrix}
            1 & 0 & 0 & \Delta t & 0 & 0 \\
            0 & 1 & 0 & 0 & \Delta t & 0 \\
            0 & 0 & 1 & 0 & 0 & \Delta t \\
            0 & 0 & 0 & 1 & 0 & 0 \\
            0 & 0 & 0 & 0 & 1 & 0 \\
            0 & 0 & 0 & 0 & 0 & 1
            \end{bmatrix}
          \]
        </p>
      </div>

      <div>
        <h2>Reading the A matrix</h2>
        <ul>
          <li>Row 1: \(x_{k+1} = x_k + v_x \Delta t\)</li>
          <li>Row 2: \(y_{k+1} = y_k + v_y \Delta t\)</li>
          <li>Row 3: \(\theta_{k+1} = \theta_k + \omega \Delta t\)</li>
          <li>Row 4: \(v_{x,k+1} = v_{x,k}\) unchanged (no friction in model)</li>
          <li>Row 5: \(v_{y,k+1} = v_{y,k}\) unchanged (no friction in model)</li>
          <li>Row 6: \(\omega_{k+1} = \omega_k\) unchanged (no friction in model)</li>
        </ul>

        <h2>Key properties</h2>
        <ul>
          <li><strong>Constant</strong> — computed once at startup and reused through the mission</li>
          <li><strong>No friction</strong> — model assumes frictionless motion</li>
          <li><strong>Simple integration</strong> — positions update from velocities</li>
        </ul>

        <p class="muted" style="margin-top: 0.5em;">
          Note: The simulation does experience friction and disturbances — MPC handles this via feedback. (More later.)
        </p>
      </div>
    </div>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Slide 18 – The B Matrix -->
  <section class="slide">
    <div class="slide-header">
      <h1>The Input Matrix \(B(\theta_k)\)</h1>
      <span class="tag">Part 3 – Dynamics</span>
    </div>

    <p><em>"How thrusters affect the state"</em></p>

    <p class="equation">
      \[
        B(\theta_k) = \Delta t
        \begin{bmatrix}
        0 & \cdots & 0 \\
        0 & \cdots & 0 \\
        0 & \cdots & 0 \\
        \frac{\cos\theta_k f_{1x} - \sin\theta_k f_{1y}}{m} & \cdots & \frac{\cos\theta_k f_{8x} - \sin\theta_k f_{8y}}{m} \\
        \frac{\sin\theta_k f_{1x} + \cos\theta_k f_{1y}}{m} & \cdots & \frac{\sin\theta_k f_{8x} + \cos\theta_k f_{8y}}{m} \\
        \tau_1 / I_z & \cdots & \tau_8 / I_z
        \end{bmatrix}
      \]
    </p>

    <div class="two-column" style="margin-top: 0.5em;">
      <div>
        <h2>Reading the matrix</h2>
        <ul>
          <li><strong>Rows 1-3:</strong> Zeros — thrusters cause acceleration, not position change directly. Position updates come from velocity via the A matrix.</li>
          <li><strong>Row 4:</strong> World-frame x-acceleration from each thruster</li>
          <li><strong>Row 5:</strong> World-frame y-acceleration from each thruster</li>
          <li><strong>Row 6:</strong> Angular acceleration from each thruster</li>
        </ul>
      </div>

      <div>
        <h2>Key observations</h2>
        <ul>
          <li><strong>Rows 4-5:</strong> Contain \(\cos\theta_k\), \(\sin\theta_k\) — body→world rotation</li>
          <li><strong>Row 6:</strong> No θₖ — torque is in body frame so no need to rotate</li>
          <li><strong>Depends on θₖ</strong> — must recompute each solve!</li>
          <li>\(f_{ix}, f_{iy}\): calibrated body-frame forces</li>
        <p class="equation">
          \[
            f_{ix} = F_i \cdot d_{ix}, \quad f_{iy} = F_i \cdot d_{iy}
          \]
        </p>
        <p class="muted">\(F_i\) = measured force magnitude, \(\mathbf{d}_i\) = thrust direction</p>
          <li>\(\tau_i\): calibrated torque from thruster \(i\)</li>
                  <p class="equation">
          \[
            \tau_i = r_{ix} \cdot f_{iy} - r_{iy} \cdot f_{ix}
          \]
        </p>
        <p class="muted">\(\mathbf{r}_i\) = thruster position relative to center of mass</p>
        </ul>
      </div>
    </div>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Slide 19 – Linear vs Nonlinear -->
  <section class="slide">
    <div class="slide-header">
      <h1>The Linearization: Freezing θ Over the Horizon</h1>
      <span class="tag">Part 3 – Key Choice</span>
    </div>

    <div class="two-column">
      <div>
        <h2>Our approach (MIQP)</h2>
        <p>Use the <strong>same</strong> \(B(\theta_k)\) for all N prediction steps:</p>
        <ul>
          <li>Step \(k\): measure \(\theta_k\), build \(B(\theta_k)\)</li>
          <li>Step \(k+1\): use \(B(\theta_k)\)</li>
          <li>Step \(k+2\): use \(B(\theta_k)\)</li>
          <li>⋮</li>
          <li>Step \(k+11\): use \(B(\theta_k)\)</li>
        </ul>
        <p class="muted" style="margin-top: 0.5em;">
          Assume θ = θₖ for all 0.72&nbsp;s of the horizon.
        </p>

        <h2>Why this works</h2>
        <ul>
          <li>Short horizon — satellite doesn't rotate much</li>
          <li>Re-solve every 60&nbsp;ms — errors corrected quickly</li>
          <li><strong>Result:</strong> Linear problem → fast, reliable solves</li>
        </ul>

        <p class="muted" style="margin-top: 0.5em;">
          <strong>Empirical validation:</strong> Largest observed Δθ per 60&nbsp;ms was <strong>1.01°</strong> — 
          freezing θ over the horizon introduces negligible error. (More in Results.)
        </p>
      </div>

      <div>
        <h2>Alternative (MINLP)</h2>
        <p>Let θ <strong>evolve</strong> over the horizon:</p>
        <ul>
          <li>Step \(k\): measure \(\theta_k\)</li>
          <li>Step \(k+1\): \(\theta_{k+1} = \theta_k + \Delta t \cdot \omega_k\)</li>
          <li>Step \(k+2\): \(\theta_{k+2} = \theta_{k+1} + \Delta t \cdot \omega_{k+1}\)</li>
          <li>⋮</li>
          <li>Step \(k+11\): \(\theta_{k+11} = \theta_{k+10} + \Delta t \cdot \omega_{k+10}\)</li>
        </ul>
        <p class="muted" style="margin-top: 0.5em;">
          Each step uses a different \(B(\theta_{k+j})\).
        </p>

        <h2>Why this is hard</h2>
        <ul>
          <li>\(\omega_{k+j}\) depends on which thrusters fire (the \(u\) we're solving for)</li>
          <li>\(\cos\theta_{k+j} \cdot u_i\) = nonlinear term</li>
          <li><strong>Result:</strong> Non-convex problem → slow, unpredictable solves</li>
        </ul>
      </div>
    </div>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Slide 20 – The Optimization Problem -->
  <section class="slide">
    <div class="slide-header">
      <h1>The Optimization Problem</h1>
      <span class="tag">Part 3 – Optimization</span>
    </div>

    <p style="margin-bottom: 0.3em;">Now we have all the pieces. MPC solves this every 60&nbsp;ms:</p>

    <p class="equation">
      \[
        \min_{\mathbf{u}_k, \dots, \mathbf{u}_{k+N-1}} \quad
        \underbrace{\sum_{j=1}^{N} \| \mathbf{x}_{k+j} - \mathbf{x}^{\text{target}} \|_Q^2}_{\text{tracking error}}
        + \underbrace{\sum_{j=0}^{N-1} \sum_{i=1}^{8} R \cdot u_{k+j,i}}_{\text{fuel usage}}
        + \underbrace{\sum_{j=0}^{N-1} \sum_{i=1}^{8} R_{\text{sw}} \cdot |u_{k+j,i} - u_{k+j-1,i}|}_{\text{switching cost}}
      \]
    </p>

    <div class="two-column" style="margin-top: 0.3em;">
      <div>
        <h2>Subject to:</h2>
        <p class="equation">
          \(\mathbf{x}_{k+j+1} = A \mathbf{x}_{k+j} + B(\theta_k) \mathbf{u}_{k+j}\) <span class="muted">— dynamics</span>
        </p>
        <p class="equation">
          \(|x|, |y| \le p_{\max}\) <span class="muted">— workspace bounds</span>
        </p>
        <p class="equation">
          \(|v_x|, |v_y| \le v_{\max}, \; |\omega| \le \omega_{\max}\) <span class="muted">— velocity limits</span>
        </p>
        <p class="equation">
          \(u_{k+j,i} \in \{0, 1\}\) <span class="muted">— binary thrusters</span>
        </p>
      </div>

      <div>
        <h2>Inputs to solver</h2>
        <ul>
          <li>\(\mathbf{x}_k\) — current state (measured)</li>
          <li>\(\mathbf{x}^{\text{target}}\) — target state</li>
          <li>\(A\), \(B(\theta_k)\) — dynamics matrices</li>
          <li>\(Q\), \(R\), \(R_{\text{sw}}\) — cost weights</li>
        </ul>

        <h2>Output from solver</h2>
        <ul>
          <li>Optimal \(\mathbf{u}_k, \mathbf{u}_{k+1}, \dots, \mathbf{u}_{k+N-1}\)</li>
          <li>We only use \(\mathbf{u}_k\) — discard the rest</li>
        </ul>
      </div>
    </div>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Slide 21 – Cost Function Terms Explained -->
  <section class="slide">
    <div class="slide-header">
      <h1>The Three Cost Terms</h1>
      <span class="tag">Part 3 – Optimization</span>
    </div>

    <div class="three-column" style="gap: 1.2em;">
      <div style="background: #fef3e8; padding: 0.6em; border-radius: 8px; border-top: 3px solid #e67e22;">
        <h2 style="margin-top: 0; color: #d35400;">1. Tracking Error</h2>
        <p class="equation">
          \[J_{\text{track}} = \sum_{j=1}^{N} (\mathbf{x}_{k+j} - \mathbf{x}^{\text{target}})^\top Q \, (\mathbf{x}_{k+j} - \mathbf{x}^{\text{target}})\]
        </p>
        <p style="margin-top: 0.3em;">Expanded:</p>
        <p class="equation">
          \[= \sum_{j=1}^{N} \Big[ Q_x (x_{k+j} - x^{\text{t}})^2 + Q_y (y_{k+j} - y^{\text{t}})^2\]
          \[+ Q_\theta (\theta_{k+j} - \theta^{\text{t}})^2 + Q_{v_x} v_{x,k+j}^2\]
          \[+ Q_{v_y} v_{y,k+j}^2 + Q_\omega \omega_{k+j}^2 \Big]\]
        </p>
        <p class="muted" style="margin-top: 0.3em;">
          Superscript t = target.
        </p>
      </div>

      <div style="background: #e8f4e8; padding: 0.6em; border-radius: 8px; border-top: 3px solid #2d8a2d;">
        <h2 style="margin-top: 0; color: #2d8a2d;">2. Fuel Usage</h2>
        <p class="equation">
          \[J_{\text{fuel}} = \sum_{j=0}^{N-1} \sum_{i=1}^{8} R \cdot u_{k+j,i}\]
        </p>
        <p style="margin-top: 0.3em;">Since \(u_{k+j,i} \in \{0, 1\}\):</p>
        <p class="equation">
          \[= R \times (\text{total thruster-on count})\]
        </p>
        <p class="muted" style="margin-top: 0.3em;">
          Each thruster firing for one timestep adds cost R.<br/>
          Encourages using fewer thrusters.
        </p>
      </div>

      <div style="background: #f0f7ff; padding: 0.6em; border-radius: 8px; border-top: 3px solid #2563eb;">
        <h2 style="margin-top: 0; color: #2563eb;">3. Switching Cost</h2>
        <p class="equation">
          \[J_{\text{switch}} = \sum_{j=0}^{N-1} \sum_{i=1}^{8} R_{\text{sw}} \cdot |u_{k+j,i} - u_{k+j-1,i}|\]
        </p>
        <p style="margin-top: 0.3em;">Since \(u \in \{0,1\}\), the absolute difference is:</p>
        <p class="equation">
          \[|u_{k+j,i} - u_{k+j-1,i}| = \begin{cases} 1 & \text{if changed} \\ 0 & \text{if same} \end{cases}\]
        </p>
        <p class="muted" style="margin-top: 0.3em;">
          Penalizes 0→1 and 1→0 transitions.<br/>
          Reduces valve wear and chatter.
        </p>
      </div>
    </div>

    <p style="margin-top: 0.8em; text-align: center; font-size: 2.0em;">
      \[J_{\text{total}} = J_{\text{track}} + J_{\text{fuel}} + J_{\text{switch}}\]
    </p>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Slide 22 – Repeating the Loop -->
  <section class="slide">
    <div class="slide-header">
      <h1>Repeating the Loop</h1>
      <span class="tag">Part 3 – Complete Loop</span>
    </div>

    <h2>Solver output</h2>
    <p style="margin-bottom: 0.5em;">
      The solver returns an \(N \times 8\) binary matrix — one row per timestep, one column per thruster:
    </p>
    <p class="equation" style="margin-bottom: 0.5em;">
      \[
        U = \begin{bmatrix} \mathbf{u}_k \\ \mathbf{u}_{k+1} \\ \vdots \\ \mathbf{u}_{k+N-1} \end{bmatrix}
        = \begin{bmatrix} u_{k,1} & u_{k,2} & \cdots & u_{k,8} \\ u_{k+1,1} & u_{k+1,2} & \cdots & u_{k+1,8} \\ \vdots & \vdots & \ddots & \vdots \\ u_{k+N-1,1} & u_{k+N-1,2} & \cdots & u_{k+N-1,8} \end{bmatrix}
        \quad \text{We only use row 1: } \mathbf{u}_k
      \]
    </p>

    <div class="two-column" style="margin-top: 0.5em;">
      <div style="background: #e8f4e8; padding: 0.8em; border-radius: 8px; border-left: 4px solid #2d8a2d;">
        <h2 style="margin-top: 0; color: #2d8a2d;">Hardware</h2>
        <ol>
          <li><strong>Send</strong> \(\mathbf{u}_k\) to satellite</li>
          <li><strong>Thrusters fire</strong> for 60&nbsp;ms</li>
          <li><strong>Real physics:</strong> friction, air currents, thruster variability</li>
          <li><strong>OptiTrack measures</strong> \(\mathbf{x}_{k+1}\) (with sensor noise)</li>
          <li><strong>MPC receives</strong> new measurement → repeat</li>
        </ol>
        <p class="muted" style="margin-top: 0.5em;">
          Model mismatch: MPC assumes no friction, but real world has it.
        </p>
      </div>

      <div style="background: #e8f0f8; padding: 0.8em; border-radius: 8px; border-left: 4px solid #2563eb;">
        <h2 style="margin-top: 0; color: #2563eb;">Simulation (Nonlinear)</h2>
        <ol>
          <li><strong>Apply</strong> \(\mathbf{u}_k\) to simulated satellite</li>
          <li><strong>Compute forces &amp; torque:</strong> \(\mathbf{F} = R(\theta_k) \sum_i u_{k,i} \mathbf{f}_i^{\text{body}}\),   \(\tau = \sum_i u_{k,i} \tau_i\)</li>
          <li><strong>Integrate velocities:</strong> \(v_{x,k+1} = v_{x,k} + \frac{F_x}{m} \Delta t\),   \(v_{y,k+1} = v_{y,k} + \frac{F_y}{m} \Delta t\),   \(\omega_{k+1} = \omega_k + \frac{\tau}{I_z} \Delta t\)</li>
          <li><strong>Integrate positions:</strong> \(x_{k+1} = x_k + v_{x,k} \Delta t\),   \(y_{k+1} = y_k + v_{y,k} \Delta t\),   \(\theta_{k+1} = \theta_k + \omega_k \Delta t\)</li>
          <li><strong>Add realism:</strong> damping + disturbances + valve delay + sensor noise</li>
          <li><strong>MPC receives</strong> new measurement → repeat</li>
        </ol>
        <p class="muted" style="margin-top: 0.5em;">
          θ evolves every step — nonlinear, unlike MPC's frozen-θ model.
        </p>
      </div>
    </div>

    <p style="margin-top: 0.8em; text-align: center;">
      <strong>Key insight:</strong> Same MPC code, same interface — only the plant differs. This enables sim-to-hardware validation.
    </p>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Slide 23 – Solver Settings -->
  <section class="slide">
    <div class="slide-header">
      <h1>Solver Settings</h1>
      <span class="tag">Part 3 – Implementation</span>
    </div>

    <p style="margin-bottom: 0.5em;">MIQP solvers like Gurobi default to finding the <strong>globally optimal</strong> solution. For real-time control, we trade optimality for speed.</p>

    <div class="two-column" style="gap: 2em;">
      <div>
        <h2>Key settings</h2>
        
        <div style="background: #fef3e8; padding: 0.5em; border-radius: 6px; border-left: 3px solid #e67e22; margin-bottom: 0.5em;">
          <p style="margin: 0;"><strong>MIP Gap = 1%</strong></p>
          <p class="muted" style="margin: 0.2em 0 0 0;">Stop when solution is within 1% of optimal (default: 0.01%)</p>
        </div>

        <div style="background: #e8f4e8; padding: 0.5em; border-radius: 6px; border-left: 3px solid #2d8a2d; margin-bottom: 0.5em;">
          <p style="margin: 0;"><strong>MIP Focus = 1</strong></p>
          <p class="muted" style="margin: 0.2em 0 0 0;">Prioritize finding feasible solutions quickly over proving optimality</p>
        </div>

        <div style="background: #f0f7ff; padding: 0.5em; border-radius: 6px; border-left: 3px solid #2563eb; margin-bottom: 0.5em;">
          <p style="margin: 0;"><strong>Time Limit = 50 ms</strong></p>
          <p class="muted" style="margin: 0.2em 0 0 0;">Hard deadline — return best solution found so far</p>
        </div>

        <div style="background: #f5f5f5; padding: 0.5em; border-radius: 6px; border-left: 3px solid #666; margin-bottom: 0.5em;">
          <p style="margin: 0;"><strong>Single thread</strong></p>
          <p class="muted" style="margin: 0.2em 0 0 0;">Multi-threading overhead exceeds benefit for small problems</p>
        </div>
      </div>

      <div>
        <h2>Why 1% MIP Gap?</h2>
        <p>The solver works by maintaining bounds:</p>
        <ul>
          <li><strong>Upper bound:</strong> best solution found so far</li>
          <li><strong>Lower bound:</strong> theoretical best possible</li>
        </ul>
        <p style="margin-top: 0.3em;">Solver stops when:</p>
        <p class="equation">
          \[\frac{\text{Upper} - \text{Lower}}{\text{Upper}} \le 0.01\]
        </p>
       
        <h2 style="margin-top: 0.6em;">Impact</h2>
        <p>Faster solve time with negligible performance loss</p>
      </div>
    </div>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Slide 24 – Warm Starting -->
  <section class="slide">
    <div class="slide-header">
      <h1>Warm Starting</h1>
      <span class="tag">Part 3 – Implementation</span>
    </div>

    <p style="margin-bottom: 0.5em;">The MIQP solver can find multiple near-optimal solutions. The initial guess biases which one the solver finds.</p>

    <div class="two-column" style="gap: 2em;">
      <div>
        <h2>Shift-and-repeat strategy</h2>
        <p style="margin-bottom: 0.3em;">After each solve, store the solution. Before the next solve:</p>
        <ol>
          <li><strong>Shift</strong> rows up: row 2 → row 1, row 3 → row 2, …</li>
          <li><strong>Repeat</strong> last row to fill the new final row</li>
          <li>Provide as initial guess to the solver</li>
        </ol>

        <h2 style="margin-top: 0.6em;">How it helps</h2>
        <p>The solver uses the initial guess as its starting starting point, then explores nearby branches first.</p>
        <p style="margin-top: 0.3em;">Because the guess already has certain thrusters "on", the solver is <strong>biased toward solutions that keep those same thrusters active</strong>.</p>
      </div>

      <div>
        <p class="equation">
          \[
            U_k = \begin{bmatrix} \mathbf{u}_k \\ \mathbf{u}_{k+1} \\ \mathbf{u}_{k+2} \\ \vdots \\ \mathbf{u}_{k+N-1} \end{bmatrix}
            \xrightarrow{\text{shift}}
            U_{k+1}^{\text{init}} = \begin{bmatrix} \mathbf{u}_{k+1} \\ \mathbf{u}_{k+2} \\ \mathbf{u}_{k+3} \\ \vdots \\ \mathbf{u}_{k+N-1} \end{bmatrix}
          \]
        </p>

        <div style="margin-top: 0.6em; background: #e8f4e8; padding: 0.6em; border-radius: 8px; border-left: 4px solid #2d8a2d;">
          <h2 style="margin-top: 0; color: #2d8a2d;">Result</h2>
          <ul style="margin-top: 0.3em;">
            <li>Solver tends to reuse same thrusters as previous step</li>
            <li>Fewer valve switches between consecutive solves</li>
            <li>Complements the explicit \(R_{\text{sw}}\) switching cost</li>
          </ul>
        </div>
      </div>
    </div>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Slide 25 – Simulation Model -->
  <section class="slide">
    <div class="slide-header">
      <h1>The Simulation Model: Adding Realism</h1>
      <span class="tag">Part 3 – Simulation</span>
    </div>

    <p style="margin-bottom: 0.3em;">Each simulation timestep \(\Delta t_{\text{sim}} = 5\text{ms}\), after applying thruster forces:</p>

    <div class="two-column" style="gap: 2em;">
      <div>
        <h2>1. Linear &amp; Rotational Damping</h2>
        <p class="equation">
          \[\mathbf{v} \mathrel{+}= \frac{-b_{\text{lin}} \cdot \mathbf{v}}{m} \Delta t, \quad \omega \mathrel{+}= \frac{-b_{\text{rot}} \cdot \omega}{I_z} \Delta t\]
        </p>
        <p class="muted">models the friction with the floor</p>

        <h2 style="margin-top: 0.5em;">2. Random Disturbances</h2>
        <p class="equation">
          \[\mathbf{v} \mathrel{+}= \frac{\mathbf{w}_F}{m} \Delta t, \quad \omega \mathrel{+}= \frac{w_\tau}{I_z} \Delta t\]
        </p>
        <p class="muted">\(\mathbf{w}_F \sim \mathcal{N}(0, 0.4^2)\) N, \(w_\tau \sim \mathcal{N}(0, 0.1^2)\) Nm — air currents, vibrations</p>

        <h2 style="margin-top: 0.5em;">3. Sensor Noise</h2>
        <p class="equation">
          \[\mathbf{x}_{\text{measured}} = \mathbf{x}_{\text{true}} + \boldsymbol{\eta}\]
        </p>
        <p class="muted">
          \(\eta_{\text{pos}} \sim \mathcal{N}(0, 0.1\text{mm})\), \(\eta_\theta \sim \mathcal{N}(0, 0.05°)\) — OptiTrack precision
        </p>
      </div>

      <div>
        <h2>4. Valve Delay &amp; Thrust Ramp-up</h2>
        <p style="margin-bottom: 0.3em;">Command at \(t=0\) → actual thrust:</p>
        <p class="equation">
          \[F_{\text{actual}}(t) = \begin{cases} 0 & t < 40\text{ms} \\ F_{\max} \cdot \frac{t - 40}{10} & 40 \le t < 50\text{ms} \\ F_{\max} & t \ge 50\text{ms} \end{cases}\]
        </p>
        <p class="muted">40ms valve delay + 10ms linear ramp — solenoid valve dynamics</p>

        <h2 style="margin-top: 0.5em;">5. θ Evolution</h2>
        <p class="equation">
          \[\theta_{k+1} = \theta_k + \omega_k \cdot \Delta t_{\text{sim}}\]
        </p>
        <p class="muted">Updated every 5ms (not frozen like MPC model)</p>

        <div style="margin-top: 0.6em; background: #e8f4e8; padding: 0.4em; border-radius: 4px; border-left: 3px solid #2d8a2d;">
          <p style="margin: 0;">
            <strong>Key:</strong> MPC knows none of this — it assumes frictionless, instant response, perfect sensing. 
            Feedback corrects for model mismatch.
          </p>
        </div>
      </div>
    </div>

    <p style="margin-top: 0.5em;"><strong>Full simulation state update (each 5ms):</strong></p>
    <p class="equation">
      \[
        \begin{bmatrix} x \\ y \\ \theta \\ v_x \\ v_y \\ \omega \end{bmatrix}_{k+1}
        =
        \begin{bmatrix} x \\ y \\ \theta \\ v_x \\ v_y \\ \omega \end{bmatrix}_{k}
        +
        \begin{bmatrix} v_x \\ v_y \\ \omega \\ 0 \\ 0 \\ 0 \end{bmatrix}_{k} \Delta t
        +
        \underbrace{\begin{bmatrix} 0 \\ 0 \\ 0 \\ F_x^{\text{thrust}}/m \\ F_y^{\text{thrust}}/m \\ \tau^{\text{thrust}}/I_z \end{bmatrix} \Delta t}_{\text{thruster forces}}
        +
        \underbrace{\begin{bmatrix} 0 \\ 0 \\ 0 \\ -b_{\text{lin}} v_x/m \\ -b_{\text{lin}} v_y/m \\ -b_{\text{rot}} \omega/I_z \end{bmatrix} \Delta t}_{\text{damping}}
        +
        \underbrace{\begin{bmatrix} 0 \\ 0 \\ 0 \\ w_{F_x}/m \\ w_{F_y}/m \\ w_\tau/I_z \end{bmatrix} \Delta t}_{\text{disturbances}}
      \]
    </p>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Slide 26 – Mission Modes and Target State -->
  <section class="slide">
    <div class="slide-header">
      <h1>Mission Modes: How \(\mathbf{x}^{\text{target}}\) is Defined</h1>
      <span class="tag">Part 4 – Missions</span>
    </div>

    <p style="margin-bottom: 0.5em;">The MPC always minimizes error to \(\mathbf{x}^{\text{target}}\). The mission software updates this target to create trajectories:</p>

    <div class="two-column" style="gap: 1.5em;">
      <div style="background: #f0f7ff; padding: 0.6em; border-radius: 8px; border-left: 4px solid #2563eb;">
        <h2 style="margin-top: 0; color: #2563eb;">Mode 1: Waypoint Navigation</h2>
        <p>User defines one or more target points with orientations.</p>
        <ol>
          <li>Set \(\mathbf{x}^{\text{target}}\) = next waypoint</li>
          <li>MPC drives satellite toward target</li>
          <li>When \(|x - x^{\text{t}}| < \epsilon\) and \(|\theta - \theta^{\text{t}}| < \epsilon\):
            <ul>
              <li>Start countdown timer</li>
              <li>If stable for full countdown → advance to next waypoint</li>
              <li>If satellite drifts out → reset timer</li>
            </ul>
          </li>
          <li>Repeat until all waypoints complete</li>
        </ol>
        <p class="muted" style="margin-top: 0.3em;">
          Target jumps discretely between waypoints.
        </p>
      </div>

      <div style="background: #f0fff4; padding: 0.6em; border-radius: 8px; border-left: 4px solid #2d8a2d;">
        <h2 style="margin-top: 0; color: #2d8a2d;">Mode 2: Shape Following</h2>
        <p>User selects shape (circle, square, triangle, hexagon, or custom DXF) + offset + speed.</p>
        <ol>
          <li>Software generates path around shape at offset distance</li>
          <li>Find closest point on path → set as initial \(\mathbf{x}^{\text{target}}\)</li>
          <li>Once positioned and stable, target jumps along path each control step:
            <p class="equation" style="margin: 0.2em 0;">
              \[\Delta d = v_{\text{target}} \cdot \Delta t_{\text{control}}\]
            </p>
          </li>
          <li>When path complete → stabilize at final point (or return to different target)</li>
        </ol>
        <p class="muted" style="margin-top: 0.3em;">
          Target jumps by \(\Delta d\) meters along path every 60ms control interval.
        </p>
      </div>
    </div>

    <p style="margin-top: 0.5em; text-align: center;">
      <strong>Key:</strong> The MPC doesn't know about waypoints or shapes — it just sees \(\mathbf{x}^{\text{target}}\) and minimizes error.
    </p>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Slide 27 – Trajectory tracking -->
  <section class="slide">
    <div class="slide-header">
      <h1>Trajectory Tracking</h1>
      <span class="tag">Part 4 – Results</span>
    </div>

    <div style="display: flex; justify-content: center; align-items: center; height: 70vh;">
      <img src="Data/Comparison/Test/trajectory_comparison_three.png" alt="Trajectory Comparison" style="max-height: 100%; max-width: 100%; object-fit: contain;">
    </div>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Slide 28 – Error and Velocity Plots -->
  <section class="slide">
    <div class="slide-header">
      <h1>Tracking Performance Metrics</h1>
      <span class="tag">Part 4 – Results</span>
    </div>

    <div style="display: flex; flex-direction: column; gap: 0.5em; height: 60vh; align-items: center;">
      <div style="display: flex; justify-content: center; flex: 1; min-height: 0;">
        <img src="Data/Comparison/Test/position_error.png" alt="Position Error" style="max-height: 100%; max-width: 100%; object-fit: contain;">
      </div>
      <div style="display: flex; gap: 0.5em; flex: 1; min-height: 0; width: 100%; justify-content: center;">
        <img src="Data/Comparison/Test/angular_error.png" alt="Angular Error" style="max-height: 100%; max-width: 50%; object-fit: contain;">
        <img src="Data/Comparison/Test/velocity_magnitude.png" alt="Velocity Magnitude" style="max-height: 100%; max-width: 50%; object-fit: contain;">
      </div>
    </div>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Slide 29 – Thruster usage comparison -->
  <section class="slide">
    <div class="slide-header">
      <h1>Thruster Usage Comparison</h1>
      <span class="tag">Part 4 – Results</span>
    </div>

    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5em; height: 78vh;">
      <div style="display: flex; flex-direction: column; align-items: center;">
        <img src="Data/Comparison/Test/thruster_usage_overlay.png" alt="Thruster Usage Overlay" style="max-height: 100%; max-width: 100%; object-fit: contain;">
      </div>
      <div style="display: flex; flex-direction: column; align-items: center;">
        <img src="Data/Comparison/Test/thruster_usage_comparison.png" alt="Thruster Usage Comparison" style="max-height: 100%; max-width: 100%; object-fit: contain;">
      </div>
    </div>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Slide 30 – Solver performance -->
  <section class="slide">
    <div class="slide-header">
      <h1>Real-Time Solver Performance</h1>
      <span class="tag">Part 4 – Results</span>
    </div>

    <div style="display: flex; justify-content: center; align-items: center; height: 78vh;">
      <img src="Data/Comparison/Test/mpc_performance.png" alt="MPC Solver Performance" style="max-height: 100%; max-width: 100%; object-fit: contain;">
    </div>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Slide 31 – Research questions revisited -->
  <section class="slide">
    <div class="slide-header">
      <h1>Research Questions Revisited</h1>
      <span class="tag">Part 4 – Results</span>
    </div>

    <ol>
      <li>
        <strong>Model accuracy for tuning:</strong><br/>
        <ul style="margin-top: 0.3em;">
          <li>Total thruster usage: 188.04s (hardware) vs 190.80s (simulation) — <strong>1.5% difference</strong></li>
          <li>Trajectory shapes align closely; simulation is smoother</li>
          <li>Mission duration: 198.00s (hardware) vs 196.16s (simulation) — <strong>0.94% error</strong></li>
          <li>MPC solver timing: max 32.10ms (hardware) vs 24.25ms (simulation), mean 4.61ms vs 5.64ms</li>
        </ul>
      </li>
      <li style="margin-top: 0.5em;">
        <strong>Compensation for asymmetric thrusters:</strong><br/>
        <ul style="margin-top: 0.3em;">
          <li>Using individual thruster calibrations in \(B(\theta_k)\) allows MPC to handle asymmetry</li>
          <li>MPC controlled platform successfully despite up to 13% thrust variation</li>
        </ul>
      </li>
      <li style="margin-top: 0.5em;">
        <strong>Real-time feasibility:</strong><br/>
        <ul style="margin-top: 0.3em;">
          <li>Mean solve time: <strong>4.61 ms</strong>, worst-case: <strong>32.10 ms</strong></li>
          <li><strong>Zero missed deadlines</strong> (all within 50ms budget / 60ms period)</li>
          <li>Experimentally verifies MILP-based control is feasible at 60ms with room for more variables</li>
        </ul>
      </li>
    </ol>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Slide 32 – Conclusions -->
  <section class="slide">
    <div class="slide-header">
      <h1>Conclusions</h1>
      <span class="tag">Summary</span>
    </div>

    <div class="two-column">
      <div>
        <h2>What was built</h2>
        <ul>
          <li>Planar air-bearing satellite testbed with 8 binary thrusters</li>
          <li>Real-time mixed-integer MPC controller (MIQP)</li>
          <li>Matched simulation environment for tuning and validation</li>
        </ul>

        <h2>What was demonstrated</h2>
        <ul>
          <li>Successful trajectory tracking for inspection-style missions</li>
          <li>Simulation accurately predicts hardware behavior</li>
          <li>MPC compensates for 13% thruster asymmetry using calibration</li>
          <li>Real-time feasibility: all solves under 50ms, mean 4.6ms</li>
        </ul>
      </div>

      <div>
        <h2>Key contributions</h2>
        <ul>
          <li>Hardware validation of MIQP-based MPC with true binary thrusters</li>
          <li>Frozen-heading linearization enables fast, predictable solves</li>
          <li>Simulation-to-hardware pipeline for controller development</li>
        </ul>

        <h2>Future directions</h2>
        <ul>
          <li>Onboard computation and state estimation</li>
          <li>Extension to 6-DOF dynamics</li>
          <li>Multi-satellite coordination scenarios</li>
        </ul>
      </div>
    </div>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Slide 33 – Thank You -->
  <section class="slide">
    <div class="center">
      <h1 class="title-main">Thank You</h1>
      <p class="subtitle" style="margin-top: 1em;">Questions?</p>
      <p style="margin-top: 2em;">
        Aevar Andri Amundinusarson Oefjoerd<br/>
        <span class="muted">M.Sc. Mechanical Engineering, University of Kentucky</span>
      </p>
    </div>
    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Backup slides (math) -->

  <!-- Backup – System Parameters -->
  <section class="slide">
    <div class="slide-header">
      <h1>System Parameters</h1>
      <span class="tag">Backup – Parameters</span>
    </div>

    <div class="three-column" style="gap: 1.5em;">
      <div>
        <h2>Physical Properties</h2>
        <table style="font-size: 1.4rem; width: 100%;">
          <tr><td>Total mass</td><td>\(m = 23.09\) kg</td></tr>
          <tr><td>Moment of inertia</td><td>\(I_z = 0.324\) kg·m²</td></tr>
          <tr><td>Chassis size</td><td>290 × 290 mm x 150 mm</td></tr>
        </table>

        <h2 style="margin-top: 0.8em;">Timing</h2>
        <table style="font-size: 1.4rem; width: 100%;">
          <tr><td>Control interval</td><td>\(\Delta t = 60\) ms</td></tr>
          <tr><td>Simulation step</td><td>\(\Delta t_{sim} = 5\) ms</td></tr>
          <tr><td>Solver time limit</td><td>50 ms</td></tr>
        </table>
      </div>

      <div>
        <h2>MPC Cost Weights</h2>
        <table style="font-size: 1.4rem; width: 100%;">
          <tr><td>\(Q_{\text{position}}\)</td><td>1000</td></tr>
          <tr><td>\(Q_{\text{velocity}}\)</td><td>1750</td></tr>
          <tr><td>\(Q_{\text{angle}}\)</td><td>1000</td></tr>
          <tr><td>\(Q_{\omega}\)</td><td>1500</td></tr>
          <tr><td>\(R_{\text{thrust}}\)</td><td>1.0</td></tr>
          <tr><td>\(R_{\text{switch}}\)</td><td>0.0</td></tr>
        </table>

        <h2 style="margin-top: 0.8em;">Horizons</h2>
        <table style="font-size: 1.4rem; width: 100%;">
          <tr><td>Prediction \(N\)</td><td>12 steps</td></tr>
          <tr><td>Control \(M\)</td><td>12 steps</td></tr>
          <tr><td>Horizon time</td><td>0.72 s</td></tr>
        </table>
      </div>

      <div>
        <h2>Constraints</h2>
        <table style="font-size: 1.4rem; width: 100%;">
          <tr><td>Max velocity</td><td>0.25 m/s</td></tr>
          <tr><td>Max \(\omega\)</td><td>\(\pi/2\) rad/s</td></tr>
          <tr><td>Position bounds</td><td>±3.0 m</td></tr>
        </table>

        <h2 style="margin-top: 0.8em;">Simulation Realism</h2>
        <table style="font-size: 1.4rem; width: 100%;">
          <tr><td>Linear damping</td><td>1.8 N/(m/s)</td></tr>
          <tr><td>Rotational damping</td><td>0.3 N·m/(rad/s)</td></tr>
          <tr><td>Valve delay</td><td>40 ms</td></tr>
          <tr><td>Thrust ramp-up</td><td>10 ms</td></tr>
          <tr><td>Disturbance force</td><td>\(\sigma = 0.4\) N</td></tr>
          <tr><td>Disturbance torque</td><td>\(\sigma = 0.1\) N·m</td></tr>
        </table>
      </div>
    </div>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Backup – Thruster Calibration -->
  <section class="slide">
    <div class="slide-header">
      <h1>Thruster Calibration</h1>
      <span class="tag">Backup – Calibration</span>
    </div>

    <div class="two-column">
      <div>
        <h2>Calibration procedure</h2>
        <ol>
          <li>Mount satellite on test stand (not floating)</li>
          <li>Connect thruster to load cell via push-to-connect fitting</li>
          <li>Tare load cell with known weight (50g)</li>
          <li>Fire each thruster for 25 pulses × 10 seconds</li>
          <li>Record force at 20 ms sampling rate</li>
          <li>Extract steady-state median force per thruster</li>
        </ol>

        <h2 style="margin-top: 0.6em;">Operating conditions</h2>
        <ul>
          <li>Air pressure: 40 PSI (regulated)</li>
          <li>Load cell: 100g max capacity</li>
          <li>Rest period: 5s between pulses</li>
        </ul>
      </div>

      <div>
        <h2>Measured thruster forces</h2>
        <table style="font-size: 1.5rem; width: 100%;">
          <tr style="background: #e5edff;"><th>Thruster</th><th>Force (N)</th><th>Deviation</th></tr>
          <tr><td>1 (Right-top)</td><td>0.441</td><td>−1.1%</td></tr>
          <tr><td>2 (Right-bottom)</td><td>0.431</td><td>−3.4%</td></tr>
          <tr><td>3 (Bottom-right)</td><td>0.428</td><td>−4.1%</td></tr>
          <tr><td>4 (Bottom-left)</td><td>0.438</td><td>−1.8%</td></tr>
          <tr><td>5 (Left-bottom)</td><td>0.469</td><td>+5.1%</td></tr>
          <tr><td>6 (Left-top)</td><td>0.447</td><td>+0.2%</td></tr>
          <tr><td>7 (Top-left)</td><td>0.467</td><td>+4.7%</td></tr>
          <tr><td>8 (Top-right)</td><td>0.484</td><td>+8.5%</td></tr>
        </table>
        <p class="muted" style="margin-top: 0.3em;">
          Mean: 0.446 N &nbsp;|&nbsp; Range: 0.428–0.484 N &nbsp;|&nbsp; Max asymmetry: ~13%
        </p>
      </div>
    </div>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Backup – Tuning Process -->
  <section class="slide">
    <div class="slide-header">
      <h1>Tuning Process</h1>
      <span class="tag">Backup – Tuning</span>
    </div>

    <div class="two-column">
      <div>
        <h2>Horizon selection (N = 12)</h2>
        <ul>
          <li>Trade-off: longer horizon sees further but increases solve time and reduces responsiveness to unpredicted disturbances</li>
          <li>N = 12 at 60ms → 0.72s lookahead</li>
          <li>Sufficient for typical maneuver speeds (0.1–0.2 m/s)</li>
          <li>96 binary variables (8 thrusters × 12 steps) solvable in &lt;50ms</li>
        </ul>

        <h2 style="margin-top: 0.6em;">Weight selection</h2>
        <ul>
          <li><strong>\(Q_{\text{pos}}\) = 1000:</strong> Strong position tracking</li>
          <li><strong>\(Q_{\text{vel}}\) = 1750:</strong> Higher than position to damp oscillations</li>
          <li><strong>\(Q_{\theta}\) = 1000:</strong> Equal priority to heading</li>
          <li><strong>\(Q_{\omega}\) = 1500:</strong> Prevent spinning</li>
          <li><strong>\(R\) = 1:</strong> Mild fuel penalty (tracking prioritized)</li>
          <li><strong>\(R_{\text{switch}}\) = 0:</strong> Not used; warm-starting approach handles switching instead</li>
        </ul>
      </div>

      <div>

        <h2 style="margin-top: 0.6em;">Adaptive velocity boost</h2>
        <p>When near target (&lt;0.25m) with residual velocity:</p>
        <p class="equation">\[Q_{\text{vel}} \leftarrow Q_{\text{vel}} \times \min(3, \text{boost})\]</p>
        <p class="muted">Helps achieve smooth stops without overshoot</p>
      </div>
    </div>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Backup – Robustness and Failure Modes -->
  <section class="slide">
    <div class="slide-header">
      <h1>Robustness and Failure Modes</h1>
      <span class="tag">Backup – Robustness</span>
    </div>

    <div class="two-column">
      <div>
        <h2>What could go wrong?</h2>
        
        <div style="background: #fff3e8; padding: 0.5em; border-radius: 6px; margin-bottom: 0.5em;">
          <p style="margin: 0;"><strong>MPC solver timeout</strong></p>
          <p class="muted" style="margin: 0.2em 0 0 0;">If solver exceeds 50ms, fallback controller activates</p>
        </div>

        <div style="background: #fff3e8; padding: 0.5em; border-radius: 6px; margin-bottom: 0.5em;">
          <p style="margin: 0;"><strong>Motion capture dropout</strong></p>
          <p class="muted" style="margin: 0.2em 0 0 0;">Thrusters turn off until recovery</p>
        </div>

        <div style="background: #fff3e8; padding: 0.5em; border-radius: 6px; margin-bottom: 0.5em;">
          <p style="margin: 0;"><strong>Thruster failure</strong></p>
          <p class="muted" style="margin: 0.2em 0 0 0;">MPC can compensate if remaining thrusters provide controllability</p>
        </div>
      </div>

      <div>
        <h2>Fallback controller</h2>
        <p>If MPC fails to solve in time:</p>
        <ul>
          <li>Simple proportional control activates</li>
          <li>Fires thrusters to reduce dominant error</li>
          <li>Position error &gt; threshold → fire toward target</li>
          <li>Angle error &gt; threshold → fire to rotate</li>
        </ul>
        <p class="muted" style="margin-top: 0.3em;">
          In all experiments: fallback was <strong>never activated</strong>
        </p>

        <h2 style="margin-top: 0.6em;">Disturbance rejection</h2>
        <ul>
          <li>MPC assumes no friction — real system has it</li>
          <li>Random air currents, floor imperfections</li>
          <li>60ms feedback loop continuously corrects</li>
          <li>No explicit disturbance model needed</li>
        </ul>
      </div>
    </div>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Backup M1 – Frames and rotation -->
  <section class="slide">
    <div class="slide-header">
      <h1>Coordinate Frames and Rotation Matrix</h1>
      <span class="tag">Backup – Math</span>
    </div>

    <div class="two-column">
      <div>
        <h2>World and body frames</h2>
        <ul>
          <li><strong>World frame:</strong> fixed to the lab floor (OptiTrack reference)</li>
          <li><strong>Body frame:</strong> fixed to the satellite chassis, rotates with heading \(\theta\)</li>
        </ul>

        <h2 style="margin-top: 0.6em;">Rotation matrix \(R(\theta)\)</h2>
        <p>Transforms vectors from body frame to world frame:</p>
        <p class="equation">
          \[
            R(\theta) =
            \begin{bmatrix}
            \cos\theta & -\sin\theta \\
            \sin\theta &  \cos\theta
            \end{bmatrix}
          \]
        </p>
      </div>

      <div>
        <h2>Applying the rotation</h2>
        <p>For thruster \(i\) with body-frame force \(\mathbf{f}_i^{\text{body}} = [f_{ix}, f_{iy}]^\top\):</p>
        <p class="equation">
          \[
            \mathbf{f}_i^{\text{world}} = R(\theta_k) \, \mathbf{f}_i^{\text{body}}
          \]
        </p>
        <p>Expanded:</p>
        <p class="equation">
          \[
            \begin{bmatrix} f_{ix}^{\text{world}} \\ f_{iy}^{\text{world}} \end{bmatrix}
            =
            \begin{bmatrix}
            \cos\theta_k & -\sin\theta_k \\
            \sin\theta_k & \cos\theta_k
            \end{bmatrix}
            \begin{bmatrix} f_{ix} \\ f_{iy} \end{bmatrix}
          \]
        </p>
        <p class="muted" style="margin-top: 0.3em;">
          The rotation uses the current heading \(\theta_k\) — this is why \(B\) depends on \(\theta_k\).
        </p>
      </div>
    </div>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Backup M2 – Discrete-time dynamics detail -->
  <section class="slide">
    <div class="slide-header">
      <h1>Discrete-Time Dynamics: \(A\) and \(B(\theta_k)\) Detail</h1>
      <span class="tag">Backup – Math</span>
    </div>

    <div class="two-column">
      <div>
        <p><strong>State-space model:</strong></p>
        <p class="equation">
          \[
            \mathbf{x}_{k+1} = A \, \mathbf{x}_k + B(\theta_k)\,\mathbf{u}_k
          \]
        </p>

        <p style="margin-top: 0.5em;"><strong>\(A\) matrix</strong> (6×6, constant, \(\Delta t = 60\) ms):</p>
        <p class="equation">
          \[
            A =
            \begin{bmatrix}
            1 & 0 & 0 & \Delta t & 0 & 0 \\
            0 & 1 & 0 & 0 & \Delta t & 0 \\
            0 & 0 & 1 & 0 & 0 & \Delta t \\
            0 & 0 & 0 & 1 & 0 & 0 \\
            0 & 0 & 0 & 0 & 1 & 0 \\
            0 & 0 & 0 & 0 & 0 & 1
            \end{bmatrix}
          \]
        </p>
        <p class="muted">Row 1: \(x_{k+1} = x_k + v_x \Delta t\)</p>
        <p class="muted">Row 2: \(y_{k+1} = y_k + v_y \Delta t\)</p>
        <p class="muted">Row 3: \(\theta_{k+1} = \theta_k + \omega \Delta t\)</p>
        <p class="muted">Rows 4-6: velocities persist (no friction in model)</p>
      </div>

      <div>
        <p><strong>\(B(\theta_k)\) matrix</strong> (6×8, recomputed each solve):</p>
        <p class="equation" style="font-size: 0.9em;">
          \[
            B(\theta_k) = \Delta t
            \begin{bmatrix}
            0 & 0 & \cdots & 0 \\
            0 & 0 & \cdots & 0 \\
            0 & 0 & \cdots & 0 \\
            \frac{f_{1x}^{\text{world}}}{m} & \frac{f_{2x}^{\text{world}}}{m} & \cdots & \frac{f_{8x}^{\text{world}}}{m} \\[0.3em]
            \frac{f_{1y}^{\text{world}}}{m} & \frac{f_{2y}^{\text{world}}}{m} & \cdots & \frac{f_{8y}^{\text{world}}}{m} \\[0.3em]
            \frac{\tau_1}{I_z} & \frac{\tau_2}{I_z} & \cdots & \frac{\tau_8}{I_z}
            \end{bmatrix}
          \]
        </p>
        <p class="muted" style="margin-top: 0.3em;">
          World-frame forces from rotation:
        </p>
        <p class="equation">
          \[
            f_{ix}^{\text{world}} = \cos\theta_k \, f_{ix} - \sin\theta_k \, f_{iy}
          \]
        </p>
        <p class="equation">
          \[
            f_{iy}^{\text{world}} = \sin\theta_k \, f_{ix} + \cos\theta_k \, f_{iy}
          \]
        </p>
        <p class="muted">
          Torques \(\tau_i\) are frame-independent (precomputed at startup)
        </p>
      </div>
    </div>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Backup M3 – Thruster mapping -->
  <section class="slide">
    <div class="slide-header">
      <h1>Thruster Force and Torque Mapping</h1>
      <span class="tag">Backup – Math</span>
    </div>

    <div class="two-column">
      <div>
        <h2>Body-frame force per thruster</h2>
        <p>Each thruster \(i\) has calibrated magnitude \(F_i\) and direction \(\mathbf{d}_i = [d_{ix}, d_{iy}]^\top\):</p>
        <p class="equation">
          \[
            \mathbf{f}_i^{\text{body}} = F_i \cdot \mathbf{d}_i =
            \begin{bmatrix} f_{ix} \\ f_{iy} \end{bmatrix}
            = \begin{bmatrix} F_i \cdot d_{ix} \\ F_i \cdot d_{iy} \end{bmatrix}
          \]
        </p>

        <h2 style="margin-top: 0.6em;">World-frame force</h2>
        <p>Rotate using current heading \(\theta_k\):</p>
        <p class="equation">
          \[
            \mathbf{f}_i^{\text{world}} = R(\theta_k) \, \mathbf{f}_i^{\text{body}}
          \]
        </p>
        <p>Expanded:</p>
        <p class="equation">
          \[
            \begin{bmatrix} f_{ix}^{\text{world}} \\ f_{iy}^{\text{world}} \end{bmatrix}
            =
            \begin{bmatrix}
            \cos\theta_k \, f_{ix} - \sin\theta_k \, f_{iy} \\
            \sin\theta_k \, f_{ix} + \cos\theta_k \, f_{iy}
            \end{bmatrix}
          \]
        </p>
      </div>

      <div>
        <h2>Torque per thruster</h2>
        <p>Thruster \(i\) at position \(\mathbf{r}_i = [r_{ix}, r_{iy}]^\top\) from center of mass:</p>
        <p class="equation">
          \[
            \tau_i = (\mathbf{r}_i \times \mathbf{f}_i^{\text{body}})_z = r_{ix} \cdot f_{iy} - r_{iy} \cdot f_{ix}
          \]
        </p>
        <p class="muted">Cross product z-component (2D case)</p>

        <h2 style="margin-top: 0.6em;">Net force and torque</h2>
        <p>Summing over all active thrusters:</p>
        <p class="equation">
          \[
            F_x = \sum_{i=1}^{8} u_i \cdot f_{ix}^{\text{world}}, \quad
            F_y = \sum_{i=1}^{8} u_i \cdot f_{iy}^{\text{world}}
          \]
        </p>
        <p class="equation">
          \[
            \tau = \sum_{i=1}^{8} u_i \cdot \tau_i
          \]
        </p>
        <p class="muted">where \(u_i \in \{0, 1\}\) is the binary command</p>
      </div>
    </div>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Backup M4 – Expanded B matrix computation -->
  <section class="slide">
    <div class="slide-header">
      <h1>Building \(B(\theta_k)\): Full Matrix Derivation</h1>
      <span class="tag">Backup – Math</span>
    </div>

    <p>Starting from Newton's laws for a rigid body in 2D:</p>
    <p class="equation">
      \[
        \dot{v}_x = \frac{F_x}{m}, \quad
        \dot{v}_y = \frac{F_y}{m}, \quad
        \dot{\omega} = \frac{\tau}{I_z}
      \]
    </p>

    <p style="margin-top: 0.3em;">Discretizing with Euler integration (\(\Delta t = 60\) ms) and substituting world-frame forces:</p>
    <p class="equation" style="font-size: 0.85em;">
      \[
        B(\theta_k) = \Delta t
        \begin{bmatrix}
        0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\[0.2em]
        0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\[0.2em]
        0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\[0.2em]
        \frac{\cos\theta_k f_{1x} - \sin\theta_k f_{1y}}{m} & \frac{\cos\theta_k f_{2x} - \sin\theta_k f_{2y}}{m} & \frac{\cos\theta_k f_{3x} - \sin\theta_k f_{3y}}{m} & \cdots & \frac{\cos\theta_k f_{8x} - \sin\theta_k f_{8y}}{m} \\[0.4em]
        \frac{\sin\theta_k f_{1x} + \cos\theta_k f_{1y}}{m} & \frac{\sin\theta_k f_{2x} + \cos\theta_k f_{2y}}{m} & \frac{\sin\theta_k f_{3x} + \cos\theta_k f_{3y}}{m} & \cdots & \frac{\sin\theta_k f_{8x} + \cos\theta_k f_{8y}}{m} \\[0.4em]
        \frac{\tau_1}{I_z} & \frac{\tau_2}{I_z} & \frac{\tau_3}{I_z} & \cdots & \frac{\tau_8}{I_z}
        \end{bmatrix}
      \]
    </p>

    <div class="two-column" style="margin-top: 0.3em;">
      <div>
        <p><strong>Row interpretation:</strong></p>
        <ul style="font-size: 1.5rem;">
          <li>Rows 1-3: zeros (thrusters affect velocity, not position directly)</li>
          <li>Row 4: \(\Delta v_x\) from each thruster (world frame)</li>
          <li>Row 5: \(\Delta v_y\) from each thruster (world frame)</li>
          <li>Row 6: \(\Delta \omega\) from each thruster (no rotation needed)</li>
        </ul>
      </div>
      <div>
        <p><strong>Precomputed at startup:</strong></p>
        <ul style="font-size: 1.5rem;">
          <li>\(f_{ix}, f_{iy}\): body-frame force components</li>
          <li>\(\tau_i = r_{ix} f_{iy} - r_{iy} f_{ix}\): torque from each thruster</li>
        </ul>
        <p><strong>Recomputed each solve:</strong></p>
        <ul style="font-size: 1.5rem;">
          <li>\(\cos\theta_k, \sin\theta_k\): rotation terms</li>
        </ul>
      </div>
    </div>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Backup M5 – Prediction matrices -->
  <section class="slide">
    <div class="slide-header">
      <h1>Prediction Matrices: Stacking the Horizon</h1>
      <span class="tag">Backup – Math</span>
    </div>

    <p>To form a single optimization problem, stack all N future states and inputs:</p>

    <div class="two-column">
      <div>
        <p><strong>Stacked state vector</strong> (\(6N \times 1\)):</p>
        <p class="equation">
          \[
            \mathbf{X} =
            \begin{bmatrix}
            \mathbf{x}_{k+1} \\ \mathbf{x}_{k+2} \\ \vdots \\ \mathbf{x}_{k+N}
            \end{bmatrix}
          \]
        </p>

        <p style="margin-top: 0.5em;"><strong>Stacked input vector</strong> (\(8N \times 1\)):</p>
        <p class="equation">
          \[
            \mathbf{U} =
            \begin{bmatrix}
            \mathbf{u}_k \\ \mathbf{u}_{k+1} \\ \vdots \\ \mathbf{u}_{k+N-1}
            \end{bmatrix}
          \]
        </p>

        <p style="margin-top: 0.5em;"><strong>Compact prediction:</strong></p>
        <p class="equation">
          \[
            \mathbf{X} = \mathcal{A} \, \mathbf{x}_k + \mathcal{B} \, \mathbf{U}
          \]
        </p>
      </div>

      <div>
        <p><strong>\(\mathcal{A}\) matrix</strong> (\(6N \times 6\)):</p>
        <p class="equation">
          \[
            \mathcal{A} =
            \begin{bmatrix}
            A \\ A^2 \\ A^3 \\ \vdots \\ A^N
            \end{bmatrix}
          \]
        </p>
        <p class="muted">Powers of A propagate the initial state forward</p>

        <p style="margin-top: 0.5em;"><strong>\(\mathcal{B}\) matrix</strong> (\(6N \times 8N\)), block-lower-triangular:</p>
        <p class="equation" style="font-size: 0.85em;">
          \[
            \mathcal{B} =
            \begin{bmatrix}
            B & 0 & 0 & \cdots & 0 \\
            AB & B & 0 & \cdots & 0 \\
            A^2B & AB & B & \cdots & 0 \\
            \vdots & \vdots & \vdots & \ddots & \vdots \\
            A^{N-1}B & A^{N-2}B & \cdots & AB & B
            \end{bmatrix}
          \]
        </p>
        <p class="muted">where \(B = B(\theta_k)\) is frozen at current heading throughout horizon</p>
      </div>
    </div>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Backup M6 – Cost details -->
  <section class="slide">
    <div class="slide-header">
      <h1>Cost Function: Expanded Form</h1>
      <span class="tag">Backup – Math</span>
    </div>

    <div class="two-column">
      <div>
        <p><strong>Tracking cost</strong> (quadratic in states):</p>
        <p class="equation">
          \[
            J_{\text{track}} =
            \sum_{j=1}^{N} \left(\mathbf{x}_{k+j} - \mathbf{x}^{\text{target}}\right)^\top Q \left(\mathbf{x}_{k+j} - \mathbf{x}^{\text{target}}\right)
          \]
        </p>

        <p style="margin-top: 0.3em;"><strong>The \(Q\) matrix</strong> (6×6 diagonal):</p>
        <p class="equation" style="font-size: 0.82em;">
          \[
            Q =
            \begin{bmatrix}
            Q_{\text{pos}} & 0 & 0 & 0 & 0 & 0 \\
            0 & Q_{\text{pos}} & 0 & 0 & 0 & 0 \\
            0 & 0 & Q_{\theta} & 0 & 0 & 0 \\
            0 & 0 & 0 & Q_{\text{vel}} & 0 & 0 \\
            0 & 0 & 0 & 0 & Q_{\text{vel}} & 0 \\
            0 & 0 & 0 & 0 & 0 & Q_{\omega}
            \end{bmatrix}
          \]
        </p>
        <p class="muted">Values: \(Q_{\text{pos}}=1000\), \(Q_{\theta}=1000\), \(Q_{\text{vel}}=1750\), \(Q_{\omega}=1500\)</p>
        <p class="muted">Expanded per step:</p>
        <p class="equation" style="font-size: 0.9em;">
          \[
            \begin{aligned}
            &Q_{\text{pos}}(x_{k+j} - x^{\text{target}})^2 + Q_{\text{pos}}(y_{k+j} - y^{\text{target}})^2 \\
            &+ Q_{\theta}(\theta_{k+j} - \theta^{\text{target}})^2 + Q_{\text{vel}}(v_{x,k+j})^2 \\
            &+ Q_{\text{vel}}(v_{y,k+j})^2 + Q_{\omega}(\omega_{k+j})^2
            \end{aligned}
          \]
        </p>
      </div>

      <div>
        <p><strong>Fuel cost</strong> (linear in binary inputs):</p>
        <p class="equation">
          \[
            J_{\text{fuel}} =
            \sum_{j=0}^{N-1} \sum_{i=1}^{8} R \cdot u_{k+j,i}
          \]
        </p>
        <p class="muted">With \(R = 1\). Counts total thruster-on time steps.</p>
        <p class="muted">Since \(u_i \in \{0,1\}\), this sums over all firing events.</p>

        <p style="margin-top: 0.5em;"><strong>Switching cost</strong> (not used: \(R_{\text{sw}} = 0\)):</p>
        <p class="equation">
          \[
            J_{\text{switch}} =
            \sum_{j=1}^{N-1} \sum_{i=1}^{8} R_{\text{sw}} \cdot |u_{k+j,i} - u_{k+j-1,i}|
          \]
        </p>
        <p class="muted">Would penalize on→off or off→on transitions.</p>
        <p class="muted">Warm-starting handles smoothness instead.</p>

        <p style="margin-top: 0.5em;"><strong>Total cost:</strong></p>
        <p class="equation">
          \[J = J_{\text{track}} + J_{\text{fuel}} + J_{\text{switch}}\]
        </p>
      </div>
    </div>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Backup M7 – Constraints expanded -->
  <section class="slide">
    <div class="slide-header">
      <h1>Constraints: Physical Limits</h1>
      <span class="tag">Backup – Math</span>
    </div>

    <div class="two-column">
      <div>
        <h2>State constraints (safety bounds)</h2>
        <p>Keep CubeSat within testbed workspace:</p>
        <p class="equation">
          \[
            \begin{aligned}
            |x| &\le 3.0 \text{ m} & &\text{(table width)} \\
            |y| &\le 3.0 \text{ m} & &\text{(table depth)} \\
            |\theta| &\le 2\pi \text{ rad} & &\text{(full rotation)} \\[0.3em]
            |v_x| &\le 0.25 \text{ m/s} & &\text{(safe speed)} \\
            |v_y| &\le 0.25 \text{ m/s} & &\text{(safe speed)} \\
            |\omega| &\le \frac{\pi}{2} \text{ rad/s} & &\text{(90°/s max spin)}
            \end{aligned}
          \]
        </p>
        <p class="muted">Applied at every timestep \(k+1, k+2, \ldots, k+N\)</p>
        
        <h2 style="margin-top: 0.6em;">Input constraints</h2>
        <p class="equation">
          \[
            u_i \in \{0, 1\} \quad \text{for each thruster } i = 1, \ldots, 8
          \]
        </p>
        <p class="muted">Thrusters are either fully on or fully off — no PWM</p>
      </div>

      <div>
        <h2>Why these limits?</h2>
        <table style="font-size: 0.85em; margin-top: 0.9em;">
          <tr><td><strong>Position</strong></td><td>Stay on epoxy testbed</td></tr>
          <tr><td><strong>Velocity</strong></td><td>Prevent collisions, allow stopping</td></tr>
          <tr><td><strong>Angular rate</strong></td><td>Keep attitude controllable</td></tr>
        </table>

        <h2 style="margin-top: 0.6em;">How the solver sees it</h2>
        <p>Each bound becomes two inequalities:</p>
        <p class="equation" style="font-size: 0.95em;">
          \[
            \underbrace{x \le 3.0}_{\text{upper}} \quad \text{and} \quad \underbrace{-x \le 3.0}_{\text{lower (i.e., } x \ge -3.0\text{)}}
          \]
        </p>
        <p style="margin-top: 0.4em;">Stacked over all 6 states and N=12 timesteps:</p>
        <p style="text-align: center; font-size: 0.9em;">
          <strong>12 constraints per state × 6 states × 2 sides = 144 inequalities</strong>
        </p>
        <p class="muted" style="margin-top: 0.4em;">Plus 8 binary variables × 12 timesteps = 96 integer decisions</p>
      </div>
    </div>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <!-- Backup M8 – Compact MIQP form -->
  <section class="slide">
    <div class="slide-header">
      <h1>Complete MIQP Formulation</h1>
      <span class="tag">Backup – Math</span>
    </div>

    <p><strong>The full optimization problem solved every 60 ms:</strong></p>
    <p class="equation">
      \[
        \min_{\mathbf{x}_{k+1:k+N},\, \mathbf{u}_{k:k+N-1}} \
        \underbrace{\sum_{j=1}^{N} \left(\mathbf{x}_{k+j} - \mathbf{x}^{\text{target}}\right)^\top Q \left(\mathbf{x}_{k+j} - \mathbf{x}^{\text{target}}\right)}_{\text{quadratic tracking cost}}
        + \underbrace{\sum_{j=0}^{N-1} \sum_{i=1}^{8} R \cdot u_{k+j,i}}_{\text{linear fuel cost}}
      \]
    </p>

    <p><strong>Subject to:</strong></p>
    <p class="equation">
      \[
        \begin{aligned}
        \mathbf{x}_{k+j+1} &= A \, \mathbf{x}_{k+j} + B(\theta_k) \, \mathbf{u}_{k+j} && \text{(dynamics, } j = 0, \ldots, N-1\text{)} \\[0.3em]
        \mathbf{x}_{\min} &\le \mathbf{x}_{k+j} \le \mathbf{x}_{\max} && \text{(state bounds, } j = 1, \ldots, N\text{)} \\[0.3em]
        u_{k+j,i} &\in \{0, 1\} && \text{(binary thrusters, } j = 0, \ldots, N-1;\, i = 1, \ldots, 8\text{)}
        \end{aligned}
      \]
    </p>

    <div class="two-column" style="margin-top: 0.5em;">
      <div>
        <h2>Why this is MIQP</h2>
        <ul>
          <li><strong>MI:</strong> Binary variables \(u_{k+j,i} \in \{0,1\}\)</li>
          <li><strong>Q:</strong> Quadratic cost in continuous states \(\mathbf{x}\)</li>
          <li><strong>P:</strong> Linear dynamics and constraints</li>
        </ul>
        <p class="muted" style="margin-top: 0.3em;">
          Note: \(u^2 = u\) for binary, so fuel cost stays linear.
        </p>
      </div>
      <div>
        <h2>Problem size (N = 12)</h2>
        <ul>
          <li>Binary variables: \(8 \times 12 = 96\)</li>
          <li>Continuous variables: \(6 \times 12 = 72\) states</li>
          <li>Dynamics constraints: \(6 \times 12 = 72\)</li>
          <li>State bound constraints: \(12 \times 12 = 144\)</li>
        </ul>
        <p class="muted" style="margin-top: 0.3em;">
          Solved by Gurobi in ~5 ms average, &lt;50 ms worst case.
        </p>
      </div>
    </div>

    <div class="progress"><div class="progress-bar"></div></div>
  </section>

  <script>
    (function() {
      const slides = Array.from(document.querySelectorAll('.slide'));
      const total = slides.length;
      let current = 0;

      // Add slide numbers to each slide
      slides.forEach((slide, idx) => {
        const slideNum = document.createElement('div');
        slideNum.className = 'slide-number';
        slideNum.textContent = (idx + 1) + ' / ' + total;
        slide.appendChild(slideNum);
      });

      function showSlide(idx) {
        if (idx < 0 || idx >= total) return;
        slides[current].classList.remove('active');
        current = idx;
        slides[current].classList.add('active');

        // Update progress bar
        const bars = slides[current].querySelectorAll('.progress-bar');
        const pct = ((current + 1) / total) * 100;
        bars.forEach(bar => {
          bar.style.width = pct + '%';
        });
      }

      function next() {
        if (current < total - 1) {
          showSlide(current + 1);
        }
      }

      function prev() {
        if (current > 0) {
          showSlide(current - 1);
        }
      }

      document.addEventListener('keydown', (e) => {
        switch (e.key) {
          case 'ArrowRight':
          case 'PageDown':
            next();
            break;
          case 'ArrowLeft':
          case 'PageUp':
            prev();
            break;
        }
      });

      // Initialize first progress bar
      showSlide(0);
    })();
  </script>
</body>
</html>
